/*
   This file is copyright (c) Patrick Moran 2011.  A license is granted to any
   party to use this file according to the terms of the Boost Software License
   version 1 as it appears below:


   Boost Software License - Version 1.0 - August 17th, 2003

   Permission is hereby granted, free of charge, to any person or organization
   obtaining a copy of the software and accompanying documentation covered by
   this license (the "Software") to use, reproduce, display, distribute,
   execute, and transmit the Software, and to prepare derivative works of the
   Software, and to permit third-parties to whom the Software is furnished to
   do so, all subject to the following:

   The copyright notices in the Software and this entire statement, including
   the above license grant, this restriction and the following disclaimer,
   must be included in all copies of the Software, in whole or in part, and
   all derivative works of the Software, unless such copies or derivative
   works are solely in the form of machine-executable object code generated by
   a source language processor.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
*/



#include <boost/preprocessor/seq/enum.hpp>
#include <boost/mpl/not.hpp>
#include <boost/mpl/and.hpp>
#include <boost/mpl/or.hpp>
#include <boost/mpl/list.hpp>
#include <boost/mpl/pop_front.hpp>
#include <boost/mpl/front.hpp>
#include <boost/mpl/fold.hpp>
#include <boost/type_traits/is_same.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/config.hpp>


#ifdef BOOST_NO_VARIADIC_TEMPLATES
#  error "Non-variadic template version not written yet"
#endif


// Generate the enable_if argument by checking the condition named cond
// against the type sequence tested, with type as the result on success
#define EN_IF(cond, tested, type)				\
  typename boost::enable_if<typename base_t::template		\
			    cond ## _cond<BOOST_PP_SEQ_ENUM(tested)>,	\
			    type>::type

// Shortcut for template parameters
#define TPARAMS template<class ...Concepts>	\
  template<class Policy, class Parent>

// Generate an overload stub
#define OVERLOAD_BEGIN(a, b, c)						\
  TPARAMS								\
  class dynamic_archetype<Concepts...>::impl::			\
  constructor_gen<Policy, Parent, a, b, c>				\
  {									\
    typedef class constructor_gen<Policy, Parent, true, true, true> base_t; \
    									\
  public:								\
    template<class TOther> explicit					\
    constructor_gen(EN_IF(explicit_constructor, (TOther), TOther)){}	\
									\
    template<class TOther>						\
    constructor_gen(EN_IF(implicit_constructor, (TOther), TOther)){}	\
									\
    template<class TFirst, class... TOthers>				\
    constructor_gen(EN_IF(constructor, (TFirst)(TOthers...), TFirst),	\
		    TOthers...) {}

#define OVERLOAD_END() }

// MPL/Type Traits shorthands
#define AND boost::mpl::and_
#define OR boost::mpl::or_
#define NOT boost::mpl::not_
#define SAME boost::is_same

// Shortcut for pulling templates from the policy
#define POLICY(cond) typename Policy::template cond



namespace dynamic_archetypes {


  // This struct exists primarily to get the templates out of the header
  template<class ...Concepts>
  struct dynamic_archetype<Concepts...>::impl
  {
    template<class A1, class A2> struct combine_concepts;
    template<class Policy,
	     class Parent,
	     bool has_def_const,
	     bool has_copy_constr,
	     bool copy_is_explicit>
    class constructor_gen;
    template<class... Concs> struct to_list;

    typedef typename to_list<Concepts...>::type concept_list;

    typedef typename
    boost::mpl::fold<typename boost::mpl::pop_front<concept_list>::type,
		     typename boost::mpl::front<concept_list>::type,
		     combine_concepts<boost::mpl::_1, boost::mpl::_2> >::type
    combined_concept;

    typedef
    constructor_gen<combined_concept,
		    typename combined_concept::Parent,
		    combined_concept::has_default_constructor::value,
		    combined_concept::has_copy_constructor::value,
		    combined_concept::copy_is_explicit::value>
    unspecified_type;
  };

  template<class ...Concepts>
  template<class T, class ...Concs>
  struct dynamic_archetype<Concepts...>::impl::to_list<T, Concs...> {
    typedef typename 
    boost::mpl::push_front<T, typename to_list<Concs...>::type >::type type;
  };

  template<class ...Concepts>
  template<class T>
  struct dynamic_archetype<Concepts...>::impl::to_list<T>{
    typedef boost::mpl::list<T> type;
  };

  /*
    Implementation Note:
      If we wish to stay C++03 compatible, we can't inherit constructors.  So
      even though we build up our dynamic archetypes recursively through
      inheritance, all the constructors must be pushed to the bottom of the
      inheritance DAG.

      To acheive this, the type returned to the user is always an instanitiation
      of constructor_gen. It's Policy parameter contains instructions on which
      constructors should be implemented.  It will then inherit from the Parent
      parameter, which is where the recursion to the other archetypes will take
      place.  Finally, three specific arguments of the recursion (is there a
      default constructor, is there a copy constructor and if there is a copy
      constructor is it explicit?) are split out since they must be specialized
      on.

      It probably seems inconsistent to go through what is essentially a lot of
      boilerplate when at least some of it could be eliminated via C++11.  We
      could go from 6 specializations to 3 by using default template parameters
      on a function (on the default constructor).  Yet we still require variadic
      templates.  The reason is that the variadic template requirement will be
      removed and emulation provided additionally.
  */
  TPARAMS
  class dynamic_archetype<Concepts...>::impl::
    constructor_gen<Policy, Parent, true, true, true>
  {
    template<class TOther> struct explicit_constructor_cond;
    template<class TOther> struct implicit_constructor_cond;    
    template<class... TOthers> struct constructor_cond; // REQUIRES VARIADICS
    friend class constructor_gen<Policy, Parent, true, true, false>;
    friend class constructor_gen<Policy, Parent, true, false, false>;
    friend class constructor_gen<Policy, Parent, false, true, true>;
    friend class constructor_gen<Policy, Parent, false, true, false>;
    friend class constructor_gen<Policy, Parent, false, false, false>;
  public:
    constructor_gen()                                 {}
    explicit constructor_gen(constructor_gen const &) {}
    template<class TOther> explicit 
    constructor_gen(typename boost::enable_if<
		      explicit_constructor_cond<TOther>,
		      TOther>::type ) {}
    template<class TOther>
    constructor_gen(typename boost::enable_if<
		      implicit_constructor_cond<TOther>, 
		      TOther>::type) {}
    template<class TFirst, class... TOthers>
    constructor_gen(typename boost::enable_if<
		      constructor_cond<TFirst, TOthers...>,
		      TFirst>::type, TOthers...) {}
  };

  OVERLOAD_BEGIN(true, true, false)
    constructor_gen()                        {}
    constructor_gen(constructor_gen const &) {}
  OVERLOAD_END();

  OVERLOAD_BEGIN(true, false, false)
    constructor_gen() {}
  private:
    constructor_gen(constructor_gen const &) {}
  OVERLOAD_END();

  OVERLOAD_BEGIN(false, true, true)
    explicit constructor_gen(constructor_gen const &) {}
  private:
    constructor_gen() {}
  OVERLOAD_END();

  OVERLOAD_BEGIN(false, true, false)
    constructor_gen(constructor_gen const &) {}
  private:
    constructor_gen() {}
  OVERLOAD_END();

  OVERLOAD_BEGIN(false, false, false)
  private:
    constructor_gen() {}
    constructor_gen(constructor_gen const &) {}
  OVERLOAD_END();


#define COND(name, policy_tag)						\
  TPARAMS								\
  template<class TOther>						\
  struct dynamic_archetype<Concepts...>::impl::			\
    constructor_gen<Policy, Parent, true, true, true>:: name ##_cond {	\
    typedef AND<NOT<SAME<TOther, constructor_gen> >,			\
		POLICY(policy_tag)<TOther> >				\
      type;								\
  }


  COND(explicit_constructor, explicitly_construct_from);
  COND(implicit_constructor, construct_from);

  TPARAMS
  template<class... TOthers>  
  struct dynamic_archetype<Concepts...>::impl::
    constructor_gen<Policy, Parent, true, true, true>::constructor_cond {
    typedef typename Policy::template construct_from<TOthers...>::type
    type;
  };

#define COMBINE(name, oper)					\
  typedef oper<typename A1::name, typename A2::name> name


  /*
    Given two architecture descriptions (A1 and A2), produce a type that
    represents their union.  The union is defined as the archetype such that if
    either of the two input archetypes have a constructor, their union has it as
    well.  Additionally, if one has an explicit single-parameter constructor and
    the other has a constructor with the same signature but not explicit, then
    the result is non-explicit.
  */
  template<class ...Concepts>
  template<class A1, class A2>
  struct dynamic_archetype<Concepts...>::impl::combine_concepts
  {
    COMBINE( has_default_constructor, OR  );
    COMBINE( has_copy_constructor,    OR  );
    COMBINE( copy_is_explicit,        AND );

    template<class T> struct construct_from : public
    OR<typename A1::template construct_from<T>, 
       typename A2::template construct_from<T> >
    {};

    template<class T> struct explicitly_construct_from : public 
    AND<NOT<construct_from<T> >,
	OR<typename A1::template explicitly_construct_from<T>,
	   typename A2::template explicitly_construct_from<T> > >
    {};
  };


}

#undef COND
#undef EN_IF
#undef OVERLOAD_BEGIN
#undef OVERLOAD_END
#undef TPARAMS
#undef AND
#undef NOT
#undef SAME
#undef POLICY
#undef COMBINE
